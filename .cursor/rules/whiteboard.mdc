---
description: Development rules and best practices for the Collaborative Whiteboard App
globs: app/**/*.tsx, app/**/*.ts, components/**/*.tsx, lib/**/*.ts, lib/**/*.tsx
alwaysApply: true
---

# Whiteboard App Development Rules

## Tech Stack Overview

- **Framework**: Next.js 14+ with App Router and TypeScript
- **Canvas**: @excalidraw/excalidraw (client-side only, dynamic import)
- **Backend**: Supabase (Auth, PostgreSQL, Realtime)
- **Styling**: Tailwind CSS with dark mode support
- **State Management**: React hooks + Supabase Realtime
- **Deployment**: Vercel (with production build testing)

### Security & Dependency Management

- **Always use latest patched versions** - Check for security vulnerabilities regularly using `npm audit`
- **Priority: Security updates** - When npm warns about security vulnerabilities (especially critical/high severity), update immediately
- **Current stable**: Next.js 14.2.35+ (patches CVE-2025-55184 and CVE-2025-55183)
- **Version strategy**: Use exact versions for critical dependencies to ensure reproducible builds and security patches

## MCP Server Integration

- **Supabase MCP**: Use `mcp_whiteboard-supabase_*` tools for database operations, migrations, and admin tasks instead of manual SQL
- **Taskmaster MCP**: Use `mcp_whiteboard-task-master-ai_*` tools for task management per [dev_workflow.mdc](mdc:.cursor/rules/taskmaster/dev_workflow.mdc)
- **Prefer MCP tools** over CLI commands when working in Cursor for better integration

## Project Structure

Follow the PRD-defined structure strictly:

```
app/
├── layout.tsx                 # Root layout with SupabaseProvider
├── page.tsx                   # Dashboard (board list)
├── login/page.tsx             # Login page (magic link)
├── auth/
│   └── callback/
│       └── route.ts           # Magic link callback handler
└── board/[slug]/page.tsx      # Dynamic board route

components/
├── auth/AuthForm.tsx          # Magic link login form (email only)
├── boards/                    # Board management components
├── canvas/                    # Excalidraw wrapper and presence
└── ui/                        # Shared UI components

lib/
├── supabase/                  # Supabase clients (browser, server, middleware)
├── actions/                   # Server actions (boards.ts)
└── utils/                     # Utilities (slug, debounce)
```

## Next.js App Router Patterns

### Server Components (Default)

- **Use Server Components by default** - They're the default export in App Router
- Server Components can directly use Supabase server client
- Server Components should fetch data and pass to Client Components as props

```typescript
// ✅ DO: Server Component fetching data
import { getBoards } from '@/lib/actions/boards'
import { BoardList } from '@/components/boards/BoardList'

export default async function DashboardPage() {
  const boards = await getBoards()
  return <BoardList boards={boards} />
}
```

### Client Components

- **Mark with 'use client'** directive at top of file
- Required for: hooks, browser APIs, Excalidraw, event handlers, state
- Use Client Components for interactive UI only

```typescript
// ✅ DO: Client Component for interactivity
'use client'

import { useState } from 'react'
import { Excalidraw } from '@excalidraw/excalidraw'

export function ExcalidrawWrapper({ initialData }) {
  const [elements, setElements] = useState(initialData.elements)
  // ...
}
```

### Dynamic Imports (Excalidraw)

- **Always use dynamic import** for Excalidraw to avoid SSR issues
- Set `ssr: false` to ensure client-side only rendering

```typescript
// ✅ DO: Dynamic import for Excalidraw
'use client'

import dynamic from 'next/dynamic'

const Excalidraw = dynamic(
  () => import('@excalidraw/excalidraw').then(mod => mod.Excalidraw),
  { 
    ssr: false,
    loading: () => <div className="flex items-center justify-center h-screen">Loading canvas...</div>
  }
)

// ❌ DON'T: Direct import (causes SSR errors)
import { Excalidraw } from '@excalidraw/excalidraw'
```

### Route Protection Middleware

- Use Next.js middleware.ts to protect routes
- Redirect unauthenticated users to /login
- Allow /login and /auth/callback without auth (magic link callback)
- **Security**: Use `getUser()` for authentication checks (verifies with server), not `getSession()` (reads from storage)

```typescript
// ✅ DO: Protected routes via middleware with secure authentication check
import { createMiddlewareClient } from '@/lib/supabase/middleware'
import { NextResponse } from 'next/server'

export async function middleware(req) {
  const res = NextResponse.next()
  const supabase = createMiddlewareClient(req, res)
  
  // Refresh session cookies (required for Server Components)
  await supabase.auth.getSession()
  
  // Verify authentication with Supabase Auth server (secure)
  const { data: { user } } = await supabase.auth.getUser()
  
  const publicPaths = ['/login', '/auth/callback']
  const isPublicPath = publicPaths.some(path => req.nextUrl.pathname.startsWith(path))
  
  if (!user && !isPublicPath) {
    return NextResponse.redirect(new URL('/login', req.url))
  }
  
  return res
}

export const config = {
  matcher: ['/((?!_next/static|_next/image|favicon.ico).*)'],
}
```

## Supabase Integration Patterns

### Client Setup

- **Browser Client**: Use in Client Components and browser-only code
- **Server Client**: Use in Server Components and Server Actions
- **Middleware Client**: Use in middleware.ts for session management

```typescript
// ✅ DO: Browser client (lib/supabase/client.ts)
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}

// ✅ DO: Server client (lib/supabase/server.ts)
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createClient() {
  const cookieStore = await cookies()
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // Handle cookie setting errors
          }
        },
      },
    }
  )
}
```

### Server Actions Pattern

- **Use Server Actions** for all database mutations (create, update, delete)
- Server Actions are async functions with 'use server' directive
- Return typed data structures
- Handle errors gracefully

```typescript
// ✅ DO: Server Action with error handling
'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'

export async function createBoard(name: string) {
  const supabase = await createClient()
  
  // Validation
  if (!name || name.trim().length === 0 || name.length > 100) {
    return { error: 'Board name must be 1-100 characters' }
  }
  
  try {
    const slug = generateSlug(name)
    
    const { data, error } = await supabase
      .from('boards')
      .insert({ name, slug, elements: [], app_state: {} })
      .select()
      .single()
    
    if (error) {
      // Handle constraint violations (duplicate slug)
      if (error.code === '23505') {
        const uniqueSlug = await generateUniqueSlug(name)
        const { data: retryData, error: retryError } = await supabase
          .from('boards')
          .insert({ name, slug: uniqueSlug, elements: [], app_state: {} })
          .select()
          .single()
        
        if (retryError) return { error: 'Failed to create board' }
        revalidatePath('/')
        return { data: retryData }
      }
      return { error: 'Failed to create board' }
    }
    
    revalidatePath('/')
    return { data }
  } catch (err) {
    console.error('Create board error:', err)
    return { error: 'An unexpected error occurred' }
  }
}
```

### Magic Link Authentication Pattern

- **Passwordless authentication** - Users added manually via Supabase UI
- Use `signInWithOtp` to send magic link via email
- Handle callback route to verify token and establish session
- Show "Check your email" message after successful request

```typescript
// ✅ DO: Magic link login server action
'use server'

import { createClient } from '@/lib/supabase/server'

export async function requestMagicLink(email: string) {
  const supabase = await createClient()
  
  // Email validation
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  if (!emailRegex.test(email)) {
    return { error: 'Invalid email format' }
  }
  
  const { error } = await supabase.auth.signInWithOtp({
    email,
    options: {
      emailRedirectTo: `${process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000'}/auth/callback`
    }
  })
  
  if (error) {
    return { error: 'Failed to send magic link. Please try again.' }
  }
  
  return { success: true }
}

// ✅ DO: Magic link callback handler (app/auth/callback/route.ts)
import { createClient } from '@/lib/supabase/server'
import { NextResponse } from 'next/server'

export async function GET(request: Request) {
  const requestUrl = new URL(request.url)
  const token_hash = requestUrl.searchParams.get('token_hash')
  const type = requestUrl.searchParams.get('type')
  const next = requestUrl.searchParams.get('next') ?? '/'
  
  if (token_hash && type) {
    const supabase = await createClient()
    
    const { error } = await supabase.auth.verifyOtp({
      type,
      token_hash,
    })
    
    if (!error) {
      return NextResponse.redirect(new URL(next, request.url))
    }
  }
  
  // Invalid or expired token
  return NextResponse.redirect(new URL('/login?error=invalid_token', request.url))
}
```

### Realtime Channel Pattern

- **One channel per board** - Create channel on mount, cleanup on unmount
- Use broadcast events for scene updates
- Track presence separately from broadcast events
- Handle reconnection gracefully

```typescript
// ✅ DO: Realtime channel with proper cleanup
'use client'

import { useEffect, useRef } from 'react'
import { createClient } from '@/lib/supabase/client'
import type { RealtimeChannel } from '@supabase/supabase-js'

export function useRealtimeBoard(boardSlug: string) {
  const channelRef = useRef<RealtimeChannel | null>(null)
  const supabase = createClient()
  
  useEffect(() => {
    // Create channel
    const channel = supabase.channel(`board:${boardSlug}`)
    
    // Subscribe to broadcast events
    channel
      .on('broadcast', { event: 'scene-update' }, ({ payload }) => {
        // Handle remote changes
        handleRemoteUpdate(payload)
      })
      .subscribe(async (status) => {
        if (status === 'SUBSCRIBED') {
          // Track presence
          await channel.track({
            user_id: user.id,
            email: user.email,
            online_at: new Date().toISOString()
          })
          
          // Sync presence changes
          channel.on('presence', { event: 'sync' }, () => {
            const state = channel.presenceState()
            setOnlineUsers(Object.values(state).flat())
          })
        }
      })
    
    channelRef.current = channel
    
    return () => {
      // Cleanup
      channel.unsubscribe()
      supabase.removeChannel(channel)
    }
  }, [boardSlug])
  
  const broadcastUpdate = (elements: any[], appState: any) => {
    channelRef.current?.send({
      type: 'broadcast',
      event: 'scene-update',
      payload: { elements, appState }
    })
  }
  
  return { broadcastUpdate }
}
```

### Using Supabase MCP Tools

- **Prefer MCP tools** for migrations and admin tasks
- Use `mcp_whiteboard-supabase_execute_sql` for one-off queries
- Use `mcp_whiteboard-supabase_apply_migration` for schema changes
- Use `mcp_whiteboard-supabase_list_tables` to inspect schema

```typescript
// ✅ DO: Use MCP tools in development workflow
// Instead of manually running SQL in Supabase dashboard,
// use MCP tools when available for better integration
```

## Excalidraw Integration

### Wrapper Component Pattern

- **Always wrap Excalidraw** in a Client Component
- Pass initial data from Server Component
- Handle onChange to broadcast updates
- Debounce saves to avoid excessive API calls
- **CRITICAL**: Never update state in `onChange` - use refs to prevent infinite loops

```typescript
// ✅ DO: Excalidraw wrapper with auto-save (prevents infinite loops)
'use client'

import { useState, useRef, useCallback, useEffect } from 'react'
import dynamic from 'next/dynamic'
import { useDebouncedCallback } from 'use-debounce'
import { updateBoard } from '@/lib/actions/boards'

const Excalidraw = dynamic(
  () => import('@excalidraw/excalidraw').then(mod => mod.Excalidraw),
  { ssr: false }
)

// Type for Excalidraw API - use any since types aren't exported correctly
type ExcalidrawAPI = any

interface ExcalidrawWrapperProps {
  initialElements: any[]
  initialAppState: any
  boardSlug: string
}

export function ExcalidrawWrapper({ 
  initialElements, 
  initialAppState, 
  boardSlug 
}: ExcalidrawWrapperProps) {
  // Use excalidrawAPI prop callback (Excalidraw doesn't support refs directly)
  const excalidrawRef = useRef<ExcalidrawAPI | null>(null)
  
  // Track initial data in ref (set once, never update)
  const initialDataRef = useRef<{ elements: any[]; appState: any } | null>(null)
  
  // Use refs to track current values without causing re-renders
  const currentElementsRef = useRef<any[]>([])
  const currentAppStateRef = useRef<any>({})
  
  // State only for UI indicators (save status, etc.)
  const [isDirty, setIsDirty] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  
  // Initialize initialData once on mount
  useEffect(() => {
    if (!initialDataRef.current) {
      initialDataRef.current = {
        elements: initialElements || [],
        appState: initialAppState || {},
      }
      currentElementsRef.current = initialElements || []
      currentAppStateRef.current = initialAppState || {}
    }
  }, []) // Empty deps - only run once
  
  // Debounced save (5 seconds)
  const saveToDb = useDebouncedCallback(async (elements: any[], appState: any) => {
    setIsSaving(true)
    const { error } = await updateBoard(boardSlug, { elements, app_state: appState })
    setIsSaving(false)
    
    if (error) {
      console.error('Save failed:', error)
      // Show user notification
    } else {
      setIsDirty(false)
    }
  }, 5000)
  
  // CRITICAL: Don't update state in handleChange - causes infinite loops
  const handleChange = useCallback(
    (elements: readonly any[], appState: any, files?: any) => {
      // Convert readonly array to mutable
      const mutableElements = [...elements]
      
      // Update refs (no re-render)
      currentElementsRef.current = mutableElements
      currentAppStateRef.current = appState
      
      // Mark as dirty and save
      setIsDirty(true)
      saveToDb(mutableElements, appState)
      
      // Broadcast to other users (if using realtime)
      // broadcastUpdate(mutableElements, appState)
    },
    [saveToDb]
  )
  
  return (
    <div className="w-full h-screen">
      <Excalidraw
        // Use excalidrawAPI prop, not ref
        excalidrawAPI={(api) => {
          excalidrawRef.current = api
        }}
        // Use ref value (set once, never updated)
        initialData={initialDataRef.current || { elements: [], appState: {} }}
        // onChange receives readonly arrays
        onChange={handleChange}
      />
    </div>
  )
}

// ❌ DON'T: Update state in onChange (causes infinite loops)
const handleChange = (elements: any[], appState: any) => {
  setElements(elements)  // ❌ This causes re-render → onChange → infinite loop
  setAppState(appState)  // ❌ This causes re-render → onChange → infinite loop
  saveToDb(elements, appState)
}

// ❌ DON'T: Pass state to initialData (causes re-initialization)
<Excalidraw
  initialData={{ elements, appState }}  // ❌ Updates cause re-init
  onChange={handleChange}
/>

// ❌ DON'T: Use ref directly (Excalidraw doesn't support it)
<Excalidraw ref={excalidrawRef} />  // ❌ Won't work
```

### Data Serialization

- **Excalidraw data is JSON-serializable** - Elements and appState can be stored as JSONB
- Always validate data structure before saving
- Handle corrupted data gracefully

```typescript
// ✅ DO: Validate and serialize Excalidraw data
function validateExcalidrawData(data: any): boolean {
  if (!data) return false
  if (!Array.isArray(data.elements)) return false
  if (typeof data.appState !== 'object') return false
  return true
}

// ✅ DO: Safe deserialization with fallback
function loadBoardData(data: any) {
  try {
    if (validateExcalidrawData(data)) {
      return {
        elements: data.elements || [],
        appState: data.app_state || {}
      }
    }
  } catch (err) {
    console.error('Failed to load board data:', err)
  }
  
  // Fallback to empty canvas
  return { elements: [], appState: {} }
}
```

### Excalidraw Type Safety

- **Excalidraw types don't export correctly** - `ExcalidrawImperativeAPI` import fails in production builds
- Use local type definitions or `any` for the API type
- `onChange` receives `readonly` arrays - convert to mutable if needed

```typescript
// ✅ DO: Use local type definition or any
// Type for Excalidraw API ref - using any since Excalidraw types aren't always exported correctly
type ExcalidrawAPI = any

// Or define minimal interface
type ExcalidrawAPI = {
  updateScene: (sceneData: { elements?: any[]; appState?: any }) => void
  getSceneElementsIncludingDeleted: () => readonly any[]
  [key: string]: any
}

// ❌ DON'T: Import types that don't work in production
import type { ExcalidrawImperativeAPI } from '@excalidraw/excalidraw/types/types'
// This fails in production builds with: "Cannot find module '@excalidraw/excalidraw/types/types'"

// ✅ DO: Handle readonly arrays from onChange
const handleChange = useCallback(
  (elements: readonly any[], appState: any, files?: any) => {
    // Convert readonly to mutable if needed
    const mutableElements = [...elements]
    // Use mutableElements for your logic
  },
  []
)
```

### Preventing Infinite Loops

- **Never update state in `onChange`** - Causes infinite re-render loops in production
- Use refs to track current values without triggering re-renders
- `initialData` should be set once on mount, never updated from state

```typescript
// ✅ DO: Use refs to track values
const currentElementsRef = useRef<any[]>([])
const currentAppStateRef = useRef<any>({})

const handleChange = useCallback((elements: readonly any[], appState: any) => {
  // Update refs (no re-render)
  currentElementsRef.current = [...elements]
  currentAppStateRef.current = appState
  
  // Only update state for UI indicators
  setIsDirty(true)
  saveToDb([...elements], appState)
}, [saveToDb])

// ❌ DON'T: Update state in onChange
const handleChange = (elements: any[], appState: any) => {
  setElements(elements)  // ❌ Causes infinite loop
  setAppState(appState)   // ❌ Causes infinite loop
}

// ✅ DO: Store initialData in ref (set once)
const initialDataRef = useRef<{ elements: any[]; appState: any } | null>(null)

useEffect(() => {
  if (!initialDataRef.current) {
    initialDataRef.current = { elements: initialElements, appState: initialAppState }
  }
}, []) // Empty deps - only set once

<Excalidraw initialData={initialDataRef.current || { elements: [], appState: {} }} />

// ❌ DON'T: Pass state to initialData
<Excalidraw initialData={{ elements, appState }} />  // ❌ Updates cause re-init
```

## Error Handling Patterns

### User-Facing Errors

- **Show user-friendly messages** - Never expose technical errors
- Provide retry options for transient failures
- Log detailed errors server-side

```typescript
// ✅ DO: User-friendly error handling
export async function createBoard(name: string) {
  try {
    // ... implementation
  } catch (error) {
    console.error('Create board error:', error) // Log server-side
    
    // Return user-friendly message
    if (error instanceof NetworkError) {
      return { error: 'Network error. Please check your connection and try again.' }
    }
    
    return { error: 'Failed to create board. Please try again.' }
  }
}

// ✅ DO: Error UI component
export function ErrorMessage({ error, onRetry }: { error: string, onRetry?: () => void }) {
  return (
    <div className="bg-red-50 border border-red-200 rounded p-4">
      <p className="text-red-800">{error}</p>
      {onRetry && (
        <button onClick={onRetry} className="mt-2 text-red-600 underline">
          Try again
        </button>
      )}
    </div>
  )
}
```

### Network Error Handling

- **Handle offline/online states** - Pause saves when offline, resume when online
- Queue failed saves for retry (up to 3 attempts with exponential backoff)
- Show connection status to users

```typescript
// ✅ DO: Network-aware auto-save
'use client'

import { useEffect, useState } from 'react'

export function useAutoSave(boardSlug: string) {
  const [isOnline, setIsOnline] = useState(true)
  const saveQueue = useRef<Array<() => Promise<void>>>([])
  
  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true)
      // Process queued saves
      saveQueue.current.forEach(save => save())
      saveQueue.current = []
    }
    
    const handleOffline = () => {
      setIsOnline(false)
    }
    
    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)
    
    return () => {
      window.removeEventListener('online', handleOnline)
      window.removeEventListener('offline', handleOffline)
    }
  }, [])
  
  const saveWithRetry = async (saveFn: () => Promise<void>, retries = 3) => {
    try {
      await saveFn()
    } catch (error) {
      if (retries > 0 && !isOnline) {
        // Queue for later
        saveQueue.current.push(() => saveWithRetry(saveFn, retries - 1))
      } else if (retries > 0) {
        // Retry with exponential backoff
        await new Promise(resolve => setTimeout(resolve, 1000 * (4 - retries)))
        return saveWithRetry(saveFn, retries - 1)
      } else {
        // Max retries exceeded - show error
        showError('Failed to save. Changes are queued and will be saved when connection is restored.')
      }
    }
  }
  
  return { isOnline, saveWithRetry }
}
```

### Validation Patterns

- **Client-side validation** - Show errors immediately
- **Server-side validation** - Always validate on server for security
- Use consistent validation functions

```typescript
// ✅ DO: Shared validation utilities
export function validateEmail(email: string): { valid: boolean; error?: string } {
  if (!email) {
    return { valid: false, error: 'Email is required' }
  }
  
  // RFC 5322 compliant email regex (simplified)
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  if (!emailRegex.test(email)) {
    return { valid: false, error: 'Invalid email format' }
  }
  
  return { valid: true }
}

// Note: Password validation not needed - using magic link authentication only
// Users are added manually via Supabase UI

export function validateBoardName(name: string): { valid: boolean; error?: string } {
  if (!name || name.trim().length === 0) {
    return { valid: false, error: 'Board name is required' }
  }
  
  if (name.length > 100) {
    return { valid: false, error: 'Board name must be 100 characters or less' }
  }
  
  return { valid: true }
}
```

## Real-time Collaboration Patterns

### Conflict Resolution

- **Last-write-wins per element** - Each Excalidraw element has unique ID
- Compare element IDs when applying updates
- Handle simultaneous creation (both preserved with unique IDs)

```typescript
// ✅ DO: Last-write-wins conflict resolution
function applyRemoteUpdate(
  localElements: any[], 
  remoteElements: any[]
): any[] {
  // Create map of remote elements by ID
  const remoteMap = new Map(remoteElements.map(el => [el.id, el]))
  
  // Update or add remote elements
  const updated = localElements.map(localEl => {
    const remoteEl = remoteMap.get(localEl.id)
    if (remoteEl) {
      // Element exists in both - last write wins (use remote)
      remoteMap.delete(localEl.id)
      return remoteEl
    }
    // Element only exists locally - keep it
    return localEl
  })
  
  // Add new remote-only elements
  remoteMap.forEach(remoteEl => updated.push(remoteEl))
  
  return updated
}
```

### Presence Management

- **Track user presence** separately from scene updates
- Handle multiple tabs from same user (deduplicate)
- Show connection status indicators

```typescript
// ✅ DO: Presence tracking with deduplication
function usePresence(channel: RealtimeChannel, userId: string) {
  const [onlineUsers, setOnlineUsers] = useState<any[]>([])
  
  useEffect(() => {
    // Deduplicate by user_id (multiple tabs = single presence)
    const handlePresenceSync = () => {
      const state = channel.presenceState()
      const users = Object.values(state)
        .flat()
        .reduce((acc, user: any) => {
          // Only keep first occurrence per user_id
          if (!acc.find(u => u.user_id === user.user_id)) {
            acc.push(user)
          }
          return acc
        }, [])
      
      setOnlineUsers(users)
    }
    
    channel.on('presence', { event: 'sync' }, handlePresenceSync)
    
    return () => {
      channel.off('presence', { event: 'sync' }, handlePresenceSync)
    }
  }, [channel])
  
  return onlineUsers
}
```

## TypeScript Best Practices

### Type Definitions

- **Define interfaces** for all data structures matching Supabase schema
- Use Supabase generated types when available
- Export types from centralized location

```typescript
// ✅ DO: Define board types
export interface Board {
  id: string
  slug: string
  name: string
  elements: any[]  // Excalidraw elements array
  app_state: any   // Excalidraw app state
  created_by: string | null
  created_at: string
  updated_at: string
}

// ✅ DO: Server action return types
export type ActionResult<T> = 
  | { data: T; error?: never }
  | { data?: never; error: string }
```

### Type Safety

- **Avoid `any`** except for Excalidraw types (they don't export proper types)
- Use type guards for runtime validation
- Leverage TypeScript strict mode
- **Excalidraw types require special handling** - imports fail in production builds

```typescript
// ✅ DO: Type guards
function isBoard(data: unknown): data is Board {
  return (
    typeof data === 'object' &&
    data !== null &&
    'id' in data &&
    'slug' in data &&
    'name' in data &&
    Array.isArray((data as any).elements)
  )
}

// ❌ DON'T: Unchecked type assertions
const board = data as Board  // Unsafe

// ✅ DO: Handle Excalidraw types (they don't export correctly)
// Use local type definition or any
type ExcalidrawAPI = any

// ❌ DON'T: Import Excalidraw types (fails in production)
import type { ExcalidrawImperativeAPI } from '@excalidraw/excalidraw/types/types'
// Error: Cannot find module '@excalidraw/excalidraw/types/types'

// ✅ DO: Handle readonly arrays from Excalidraw onChange
const handleChange = (elements: readonly any[], appState: any) => {
  const mutable = [...elements] // Convert if needed
}
```

## Styling with Tailwind CSS

### Utility-First Approach

- **Use Tailwind utilities** directly in components
- Follow consistent spacing scale (p-4, m-4, gap-4, etc.)
- Use dark mode variants when needed

```typescript
// ✅ DO: Tailwind utilities
<div className="flex flex-col gap-4 p-6 bg-white dark:bg-gray-900 rounded-lg shadow">
  <h2 className="text-2xl font-bold text-gray-900 dark:text-white">
    Board Name
  </h2>
  <p className="text-gray-600 dark:text-gray-400">Last updated: {date}</p>
</div>
```

### Component Styling

- **Extract reusable components** for common patterns
- Keep component-specific styles inline with Tailwind
- Use `className` prop for customization

```typescript
// ✅ DO: Reusable styled component
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'danger'
}

export function Button({ variant = 'primary', className, ...props }: ButtonProps) {
  const baseClasses = 'px-4 py-2 rounded font-medium transition-colors'
  const variantClasses = {
    primary: 'bg-blue-600 text-white hover:bg-blue-700',
    secondary: 'bg-gray-200 text-gray-900 hover:bg-gray-300',
    danger: 'bg-red-600 text-white hover:bg-red-700',
  }
  
  return (
    <button
      className={`${baseClasses} ${variantClasses[variant]} ${className || ''}`}
      {...props}
    />
  )
}
```

## Testing Patterns

### Component Testing

- **Test UI components** in isolation using React Testing Library
- Mock Supabase clients in tests
- Test error states and loading states

```typescript
// ✅ DO: Component test with mocked Supabase
import { render, screen, waitFor } from '@testing-library/react'
import { createClient } from '@/lib/supabase/client'
import { BoardList } from '@/components/boards/BoardList'

jest.mock('@/lib/supabase/client')

test('displays board list', async () => {
  const mockBoards = [
    { id: '1', name: 'Test Board', slug: 'test-board' }
  ]
  
  ;(createClient as jest.Mock).mockReturnValue({
    from: () => ({
      select: () => ({ data: mockBoards, error: null })
    })
  })
  
  render(<BoardList boards={mockBoards} />)
  
  await waitFor(() => {
    expect(screen.getByText('Test Board')).toBeInTheDocument()
  })
})
```

## Performance Considerations

### Code Splitting

- **Use dynamic imports** for heavy components (Excalidraw)
- Split routes automatically via App Router
- Lazy load non-critical components

### Optimization

- **Debounce auto-save** (5 seconds) to avoid excessive writes
- Use React.memo for expensive components
- Optimize images with Next.js Image component (if used)
- **CRITICAL**: Avoid infinite loops in Excalidraw onChange handlers

```typescript
// ✅ DO: Memoize expensive components
export const BoardCard = React.memo(function BoardCard({ board }: { board: Board }) {
  // Component implementation
})

// ⚠️ WARNING: Infinite Loop Prevention
// Never update state in Excalidraw onChange - causes React error #185 in production
// Use refs to track values instead of state updates
```

## Production Build Testing

- **Always test production builds locally** before deploying
- Production builds expose issues that dev mode masks
- React behavior differs between dev and production

### Testing Production Builds Locally

```bash
# Build and test production build locally
npm run build
npm start

# Test on http://localhost:3000
```

### Why Production Builds Matter

- **Faster execution** exposes timing issues and infinite loops
- **Optimized code** can surface race conditions
- **Different error handling** - minified errors are harder to debug
- **React Strict Mode** behaves differently in production
- **No HMR** - state resets don't mask persistent issues

### Common Production-Only Issues

1. **Infinite loops** - State updates in callbacks cause loops in production
2. **Type errors** - Type imports that work in dev fail in production builds
3. **Timing issues** - Race conditions only appear with optimized code
4. **Error boundaries** - Production error handling differs from dev

### Debugging Production Builds

```typescript
// ✅ DO: Add console logs to track behavior
const handleChange = useCallback((elements: readonly any[], appState: any) => {
  console.log('onChange called', elements.length) // Track call frequency
  // ... implementation
}, [])

// ✅ DO: Use React DevTools Profiler to detect excessive re-renders
// ✅ DO: Monitor browser Performance tab for update loops
```

## Vercel Deployment Considerations

### Environment Variables

- **Set all required variables** in Vercel project settings
- Use Production, Preview, and Development environments
- Never commit `.env.local` to git

```bash
# Required environment variables in Vercel
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
NEXT_PUBLIC_SITE_URL=https://your-app.vercel.app
```

### Supabase Configuration

- **Update redirect URLs** in Supabase Dashboard → Authentication → URL Configuration
- Add production URL: `https://your-app.vercel.app/auth/callback`
- Add preview pattern: `https://your-app-*.vercel.app/auth/callback`
- Set Site URL to your production domain

### Build Error Debugging

- **Check build logs** in Vercel dashboard for TypeScript errors
- **Common issues**:
  - Missing environment variables
  - Type imports that fail in production
  - Infinite loop errors (React error #185)
- **Test locally first**: `npm run build` before pushing

### Deployment Checklist

- [ ] All environment variables set in Vercel
- [ ] Supabase redirect URLs configured
- [ ] Production build succeeds locally (`npm run build`)
- [ ] No TypeScript errors in build
- [ ] Test authentication flow in production
- [ ] Verify board creation/editing works
- [ ] Check for infinite loops (React error #185)

## Environment Variables

### Required Variables

```bash
# .env.local
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
```

- **Never commit** `.env.local` to git
- Use `NEXT_PUBLIC_` prefix for client-accessible variables
- Validate env vars at build time

```typescript
// ✅ DO: Validate environment variables
if (!process.env.NEXT_PUBLIC_SUPABASE_URL) {
  throw new Error('Missing NEXT_PUBLIC_SUPABASE_URL')
}

if (!process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY) {
  throw new Error('Missing NEXT_PUBLIC_SUPABASE_ANON_KEY')
}
```

## Taskmaster Integration

- **Follow [dev_workflow.mdc](mdc:.cursor/rules/taskmaster/dev_workflow.mdc)** for task management
- Use Taskmaster MCP tools for task operations
- Update subtasks with implementation findings
- Mark tasks as done when complete

## Code Organization

### File Naming

- **Use kebab-case** for file names: `board-card.tsx`, `auth-form.tsx`
- Use PascalCase for component names: `BoardCard`, `AuthForm`
- Keep file names descriptive and aligned with component names

### Export Patterns

- **Named exports** for components and utilities
- Default exports only for pages and layouts
- Group related exports in index files when helpful

```typescript
// ✅ DO: Named exports
export function createBoard(name: string) { }
export function updateBoard(slug: string, data: BoardData) { }
export function deleteBoard(slug: string) { }

// ✅ DO: Default export for pages
export default function DashboardPage() { }
```

## Git Workflow

### Commit Messages

- Use conventional commits: `feat:`, `fix:`, `refactor:`, `docs:`, etc.
- Reference task IDs when applicable: `feat(board): implement auto-save (task #7)`
- Include scope: `feat(auth): add email validation`

### Branch Strategy

- Create feature branches from main
- Use Taskmaster tags for feature isolation if needed
- Keep commits focused and atomic

## References

- [Next.js App Router Docs](https://nextjs.org/docs/app)
- [Supabase Docs](https://supabase.com/docs)
- [Excalidraw Docs](https://docs.excalidraw.com/)
- [PRD](mdc:.taskmaster/docs/prd.txt)
- [Taskmaster Workflow](mdc:.cursor/rules/taskmaster/dev_workflow.mdc)