---
description: Development rules and best practices for the Collaborative Whiteboard App
globs: app/**/*.tsx, app/**/*.ts, components/**/*.tsx, lib/**/*.ts, lib/**/*.tsx
alwaysApply: true
---

# Whiteboard App Development Rules

## Tech Stack Overview

- **Framework**: Next.js 14+ with App Router and TypeScript
- **Canvas**: @excalidraw/excalidraw (client-side only, dynamic import)
- **Backend**: Supabase (Auth, PostgreSQL, Realtime)
- **Styling**: Tailwind CSS with dark mode support
- **State Management**: React hooks + Supabase Realtime
- **Deployment**: Docker with multi-stage builds

## MCP Server Integration

- **Supabase MCP**: Use `mcp_whiteboard-supabase_*` tools for database operations, migrations, and admin tasks instead of manual SQL
- **Taskmaster MCP**: Use `mcp_whiteboard-task-master-ai_*` tools for task management per [dev_workflow.mdc](mdc:.cursor/rules/taskmaster/dev_workflow.mdc)
- **Prefer MCP tools** over CLI commands when working in Cursor for better integration

## Project Structure

Follow the PRD-defined structure strictly:

```
app/
├── layout.tsx                 # Root layout with SupabaseProvider
├── page.tsx                   # Dashboard (board list)
├── login/page.tsx             # Login page
├── signup/page.tsx            # Signup page
└── board/[slug]/page.tsx      # Dynamic board route

components/
├── auth/AuthForm.tsx          # Reusable login/signup form
├── boards/                    # Board management components
├── canvas/                    # Excalidraw wrapper and presence
└── ui/                        # Shared UI components

lib/
├── supabase/                  # Supabase clients (browser, server, middleware)
├── actions/                   # Server actions (boards.ts)
└── utils/                     # Utilities (slug, debounce)
```

## Next.js App Router Patterns

### Server Components (Default)

- **Use Server Components by default** - They're the default export in App Router
- Server Components can directly use Supabase server client
- Server Components should fetch data and pass to Client Components as props

```typescript
// ✅ DO: Server Component fetching data
import { getBoards } from '@/lib/actions/boards'
import { BoardList } from '@/components/boards/BoardList'

export default async function DashboardPage() {
  const boards = await getBoards()
  return <BoardList boards={boards} />
}
```

### Client Components

- **Mark with 'use client'** directive at top of file
- Required for: hooks, browser APIs, Excalidraw, event handlers, state
- Use Client Components for interactive UI only

```typescript
// ✅ DO: Client Component for interactivity
'use client'

import { useState } from 'react'
import { Excalidraw } from '@excalidraw/excalidraw'

export function ExcalidrawWrapper({ initialData }) {
  const [elements, setElements] = useState(initialData.elements)
  // ...
}
```

### Dynamic Imports (Excalidraw)

- **Always use dynamic import** for Excalidraw to avoid SSR issues
- Set `ssr: false` to ensure client-side only rendering

```typescript
// ✅ DO: Dynamic import for Excalidraw
'use client'

import dynamic from 'next/dynamic'

const Excalidraw = dynamic(
  () => import('@excalidraw/excalidraw').then(mod => mod.Excalidraw),
  { 
    ssr: false,
    loading: () => <div className="flex items-center justify-center h-screen">Loading canvas...</div>
  }
)

// ❌ DON'T: Direct import (causes SSR errors)
import { Excalidraw } from '@excalidraw/excalidraw'
```

### Route Protection Middleware

- Use Next.js middleware.ts to protect routes
- Redirect unauthenticated users to /login
- Allow /login and /signup without auth

```typescript
// ✅ DO: Protected routes via middleware
import { createMiddlewareClient } from '@/lib/supabase/middleware'
import { NextResponse } from 'next/server'

export async function middleware(req) {
  const res = NextResponse.next()
  const supabase = createMiddlewareClient(req, res)
  
  const { data: { session } } = await supabase.auth.getSession()
  
  if (!session && !req.nextUrl.pathname.startsWith('/login') && !req.nextUrl.pathname.startsWith('/signup')) {
    return NextResponse.redirect(new URL('/login', req.url))
  }
  
  return res
}

export const config = {
  matcher: ['/((?!_next/static|_next/image|favicon.ico).*)'],
}
```

## Supabase Integration Patterns

### Client Setup

- **Browser Client**: Use in Client Components and browser-only code
- **Server Client**: Use in Server Components and Server Actions
- **Middleware Client**: Use in middleware.ts for session management

```typescript
// ✅ DO: Browser client (lib/supabase/client.ts)
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}

// ✅ DO: Server client (lib/supabase/server.ts)
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createClient() {
  const cookieStore = await cookies()
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // Handle cookie setting errors
          }
        },
      },
    }
  )
}
```

### Server Actions Pattern

- **Use Server Actions** for all database mutations (create, update, delete)
- Server Actions are async functions with 'use server' directive
- Return typed data structures
- Handle errors gracefully

```typescript
// ✅ DO: Server Action with error handling
'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'

export async function createBoard(name: string) {
  const supabase = await createClient()
  
  // Validation
  if (!name || name.trim().length === 0 || name.length > 100) {
    return { error: 'Board name must be 1-100 characters' }
  }
  
  try {
    const slug = generateSlug(name)
    
    const { data, error } = await supabase
      .from('boards')
      .insert({ name, slug, elements: [], app_state: {} })
      .select()
      .single()
    
    if (error) {
      // Handle constraint violations (duplicate slug)
      if (error.code === '23505') {
        const uniqueSlug = await generateUniqueSlug(name)
        const { data: retryData, error: retryError } = await supabase
          .from('boards')
          .insert({ name, slug: uniqueSlug, elements: [], app_state: {} })
          .select()
          .single()
        
        if (retryError) return { error: 'Failed to create board' }
        revalidatePath('/')
        return { data: retryData }
      }
      return { error: 'Failed to create board' }
    }
    
    revalidatePath('/')
    return { data }
  } catch (err) {
    console.error('Create board error:', err)
    return { error: 'An unexpected error occurred' }
  }
}
```

### Realtime Channel Pattern

- **One channel per board** - Create channel on mount, cleanup on unmount
- Use broadcast events for scene updates
- Track presence separately from broadcast events
- Handle reconnection gracefully

```typescript
// ✅ DO: Realtime channel with proper cleanup
'use client'

import { useEffect, useRef } from 'react'
import { createClient } from '@/lib/supabase/client'
import type { RealtimeChannel } from '@supabase/supabase-js'

export function useRealtimeBoard(boardSlug: string) {
  const channelRef = useRef<RealtimeChannel | null>(null)
  const supabase = createClient()
  
  useEffect(() => {
    // Create channel
    const channel = supabase.channel(`board:${boardSlug}`)
    
    // Subscribe to broadcast events
    channel
      .on('broadcast', { event: 'scene-update' }, ({ payload }) => {
        // Handle remote changes
        handleRemoteUpdate(payload)
      })
      .subscribe(async (status) => {
        if (status === 'SUBSCRIBED') {
          // Track presence
          await channel.track({
            user_id: user.id,
            email: user.email,
            online_at: new Date().toISOString()
          })
          
          // Sync presence changes
          channel.on('presence', { event: 'sync' }, () => {
            const state = channel.presenceState()
            setOnlineUsers(Object.values(state).flat())
          })
        }
      })
    
    channelRef.current = channel
    
    return () => {
      // Cleanup
      channel.unsubscribe()
      supabase.removeChannel(channel)
    }
  }, [boardSlug])
  
  const broadcastUpdate = (elements: any[], appState: any) => {
    channelRef.current?.send({
      type: 'broadcast',
      event: 'scene-update',
      payload: { elements, appState }
    })
  }
  
  return { broadcastUpdate }
}
```

### Using Supabase MCP Tools

- **Prefer MCP tools** for migrations and admin tasks
- Use `mcp_whiteboard-supabase_execute_sql` for one-off queries
- Use `mcp_whiteboard-supabase_apply_migration` for schema changes
- Use `mcp_whiteboard-supabase_list_tables` to inspect schema

```typescript
// ✅ DO: Use MCP tools in development workflow
// Instead of manually running SQL in Supabase dashboard,
// use MCP tools when available for better integration
```

## Excalidraw Integration

### Wrapper Component Pattern

- **Always wrap Excalidraw** in a Client Component
- Pass initial data from Server Component
- Handle onChange to broadcast updates
- Debounce saves to avoid excessive API calls

```typescript
// ✅ DO: Excalidraw wrapper with auto-save
'use client'

import { useEffect, useRef } from 'react'
import dynamic from 'next/dynamic'
import { useDebouncedCallback } from 'use-debounce'
import { updateBoard } from '@/lib/actions/boards'

const Excalidraw = dynamic(
  () => import('@excalidraw/excalidraw').then(mod => mod.Excalidraw),
  { ssr: false }
)

interface ExcalidrawWrapperProps {
  initialElements: any[]
  initialAppState: any
  boardSlug: string
}

export function ExcalidrawWrapper({ 
  initialElements, 
  initialAppState, 
  boardSlug 
}: ExcalidrawWrapperProps) {
  const excalidrawRef = useRef<any>(null)
  const [elements, setElements] = useState(initialElements)
  const [appState, setAppState] = useState(initialAppState)
  
  // Debounced save (5 seconds)
  const saveToDb = useDebouncedCallback(async (elements: any[], appState: any) => {
    const { error } = await updateBoard(boardSlug, { elements, app_state: appState })
    if (error) {
      console.error('Save failed:', error)
      // Show user notification
    }
  }, 5000)
  
  const handleChange = (elements: any[], appState: any) => {
    setElements(elements)
    setAppState(appState)
    
    // Save to database
    saveToDb(elements, appState)
    
    // Broadcast to other users (if using realtime)
    broadcastUpdate(elements, appState)
  }
  
  return (
    <div className="w-full h-screen">
      <Excalidraw
        ref={excalidrawRef}
        initialData={{
          elements: initialElements,
          appState: initialAppState,
        }}
        onChange={handleChange}
      />
    </div>
  )
}
```

### Data Serialization

- **Excalidraw data is JSON-serializable** - Elements and appState can be stored as JSONB
- Always validate data structure before saving
- Handle corrupted data gracefully

```typescript
// ✅ DO: Validate and serialize Excalidraw data
function validateExcalidrawData(data: any): boolean {
  if (!data) return false
  if (!Array.isArray(data.elements)) return false
  if (typeof data.appState !== 'object') return false
  return true
}

// ✅ DO: Safe deserialization with fallback
function loadBoardData(data: any) {
  try {
    if (validateExcalidrawData(data)) {
      return {
        elements: data.elements || [],
        appState: data.app_state || {}
      }
    }
  } catch (err) {
    console.error('Failed to load board data:', err)
  }
  
  // Fallback to empty canvas
  return { elements: [], appState: {} }
}
```

## Error Handling Patterns

### User-Facing Errors

- **Show user-friendly messages** - Never expose technical errors
- Provide retry options for transient failures
- Log detailed errors server-side

```typescript
// ✅ DO: User-friendly error handling
export async function createBoard(name: string) {
  try {
    // ... implementation
  } catch (error) {
    console.error('Create board error:', error) // Log server-side
    
    // Return user-friendly message
    if (error instanceof NetworkError) {
      return { error: 'Network error. Please check your connection and try again.' }
    }
    
    return { error: 'Failed to create board. Please try again.' }
  }
}

// ✅ DO: Error UI component
export function ErrorMessage({ error, onRetry }: { error: string, onRetry?: () => void }) {
  return (
    <div className="bg-red-50 border border-red-200 rounded p-4">
      <p className="text-red-800">{error}</p>
      {onRetry && (
        <button onClick={onRetry} className="mt-2 text-red-600 underline">
          Try again
        </button>
      )}
    </div>
  )
}
```

### Network Error Handling

- **Handle offline/online states** - Pause saves when offline, resume when online
- Queue failed saves for retry (up to 3 attempts with exponential backoff)
- Show connection status to users

```typescript
// ✅ DO: Network-aware auto-save
'use client'

import { useEffect, useState } from 'react'

export function useAutoSave(boardSlug: string) {
  const [isOnline, setIsOnline] = useState(true)
  const saveQueue = useRef<Array<() => Promise<void>>>([])
  
  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true)
      // Process queued saves
      saveQueue.current.forEach(save => save())
      saveQueue.current = []
    }
    
    const handleOffline = () => {
      setIsOnline(false)
    }
    
    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)
    
    return () => {
      window.removeEventListener('online', handleOnline)
      window.removeEventListener('offline', handleOffline)
    }
  }, [])
  
  const saveWithRetry = async (saveFn: () => Promise<void>, retries = 3) => {
    try {
      await saveFn()
    } catch (error) {
      if (retries > 0 && !isOnline) {
        // Queue for later
        saveQueue.current.push(() => saveWithRetry(saveFn, retries - 1))
      } else if (retries > 0) {
        // Retry with exponential backoff
        await new Promise(resolve => setTimeout(resolve, 1000 * (4 - retries)))
        return saveWithRetry(saveFn, retries - 1)
      } else {
        // Max retries exceeded - show error
        showError('Failed to save. Changes are queued and will be saved when connection is restored.')
      }
    }
  }
  
  return { isOnline, saveWithRetry }
}
```

### Validation Patterns

- **Client-side validation** - Show errors immediately
- **Server-side validation** - Always validate on server for security
- Use consistent validation functions

```typescript
// ✅ DO: Shared validation utilities
export function validateEmail(email: string): { valid: boolean; error?: string } {
  if (!email) {
    return { valid: false, error: 'Email is required' }
  }
  
  // RFC 5322 compliant email regex (simplified)
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  if (!emailRegex.test(email)) {
    return { valid: false, error: 'Invalid email format' }
  }
  
  return { valid: true }
}

export function validatePassword(password: string): { valid: boolean; error?: string } {
  if (!password) {
    return { valid: false, error: 'Password is required' }
  }
  
  if (password.length < 8) {
    return { valid: false, error: 'Password must be at least 8 characters' }
  }
  
  return { valid: true }
}

export function validateBoardName(name: string): { valid: boolean; error?: string } {
  if (!name || name.trim().length === 0) {
    return { valid: false, error: 'Board name is required' }
  }
  
  if (name.length > 100) {
    return { valid: false, error: 'Board name must be 100 characters or less' }
  }
  
  return { valid: true }
}
```

## Real-time Collaboration Patterns

### Conflict Resolution

- **Last-write-wins per element** - Each Excalidraw element has unique ID
- Compare element IDs when applying updates
- Handle simultaneous creation (both preserved with unique IDs)

```typescript
// ✅ DO: Last-write-wins conflict resolution
function applyRemoteUpdate(
  localElements: any[], 
  remoteElements: any[]
): any[] {
  // Create map of remote elements by ID
  const remoteMap = new Map(remoteElements.map(el => [el.id, el]))
  
  // Update or add remote elements
  const updated = localElements.map(localEl => {
    const remoteEl = remoteMap.get(localEl.id)
    if (remoteEl) {
      // Element exists in both - last write wins (use remote)
      remoteMap.delete(localEl.id)
      return remoteEl
    }
    // Element only exists locally - keep it
    return localEl
  })
  
  // Add new remote-only elements
  remoteMap.forEach(remoteEl => updated.push(remoteEl))
  
  return updated
}
```

### Presence Management

- **Track user presence** separately from scene updates
- Handle multiple tabs from same user (deduplicate)
- Show connection status indicators

```typescript
// ✅ DO: Presence tracking with deduplication
function usePresence(channel: RealtimeChannel, userId: string) {
  const [onlineUsers, setOnlineUsers] = useState<any[]>([])
  
  useEffect(() => {
    // Deduplicate by user_id (multiple tabs = single presence)
    const handlePresenceSync = () => {
      const state = channel.presenceState()
      const users = Object.values(state)
        .flat()
        .reduce((acc, user: any) => {
          // Only keep first occurrence per user_id
          if (!acc.find(u => u.user_id === user.user_id)) {
            acc.push(user)
          }
          return acc
        }, [])
      
      setOnlineUsers(users)
    }
    
    channel.on('presence', { event: 'sync' }, handlePresenceSync)
    
    return () => {
      channel.off('presence', { event: 'sync' }, handlePresenceSync)
    }
  }, [channel])
  
  return onlineUsers
}
```

## TypeScript Best Practices

### Type Definitions

- **Define interfaces** for all data structures matching Supabase schema
- Use Supabase generated types when available
- Export types from centralized location

```typescript
// ✅ DO: Define board types
export interface Board {
  id: string
  slug: string
  name: string
  elements: any[]  // Excalidraw elements array
  app_state: any   // Excalidraw app state
  created_by: string | null
  created_at: string
  updated_at: string
}

// ✅ DO: Server action return types
export type ActionResult<T> = 
  | { data: T; error?: never }
  | { data?: never; error: string }
```

### Type Safety

- **Avoid `any`** except for Excalidraw types (they don't export proper types)
- Use type guards for runtime validation
- Leverage TypeScript strict mode

```typescript
// ✅ DO: Type guards
function isBoard(data: unknown): data is Board {
  return (
    typeof data === 'object' &&
    data !== null &&
    'id' in data &&
    'slug' in data &&
    'name' in data &&
    Array.isArray((data as any).elements)
  )
}

// ❌ DON'T: Unchecked type assertions
const board = data as Board  // Unsafe
```

## Styling with Tailwind CSS

### Utility-First Approach

- **Use Tailwind utilities** directly in components
- Follow consistent spacing scale (p-4, m-4, gap-4, etc.)
- Use dark mode variants when needed

```typescript
// ✅ DO: Tailwind utilities
<div className="flex flex-col gap-4 p-6 bg-white dark:bg-gray-900 rounded-lg shadow">
  <h2 className="text-2xl font-bold text-gray-900 dark:text-white">
    Board Name
  </h2>
  <p className="text-gray-600 dark:text-gray-400">Last updated: {date}</p>
</div>
```

### Component Styling

- **Extract reusable components** for common patterns
- Keep component-specific styles inline with Tailwind
- Use `className` prop for customization

```typescript
// ✅ DO: Reusable styled component
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'danger'
}

export function Button({ variant = 'primary', className, ...props }: ButtonProps) {
  const baseClasses = 'px-4 py-2 rounded font-medium transition-colors'
  const variantClasses = {
    primary: 'bg-blue-600 text-white hover:bg-blue-700',
    secondary: 'bg-gray-200 text-gray-900 hover:bg-gray-300',
    danger: 'bg-red-600 text-white hover:bg-red-700',
  }
  
  return (
    <button
      className={`${baseClasses} ${variantClasses[variant]} ${className || ''}`}
      {...props}
    />
  )
}
```

## Testing Patterns

### Component Testing

- **Test UI components** in isolation using React Testing Library
- Mock Supabase clients in tests
- Test error states and loading states

```typescript
// ✅ DO: Component test with mocked Supabase
import { render, screen, waitFor } from '@testing-library/react'
import { createClient } from '@/lib/supabase/client'
import { BoardList } from '@/components/boards/BoardList'

jest.mock('@/lib/supabase/client')

test('displays board list', async () => {
  const mockBoards = [
    { id: '1', name: 'Test Board', slug: 'test-board' }
  ]
  
  ;(createClient as jest.Mock).mockReturnValue({
    from: () => ({
      select: () => ({ data: mockBoards, error: null })
    })
  })
  
  render(<BoardList boards={mockBoards} />)
  
  await waitFor(() => {
    expect(screen.getByText('Test Board')).toBeInTheDocument()
  })
})
```

## Performance Considerations

### Code Splitting

- **Use dynamic imports** for heavy components (Excalidraw)
- Split routes automatically via App Router
- Lazy load non-critical components

### Optimization

- **Debounce auto-save** (5 seconds) to avoid excessive writes
- Use React.memo for expensive components
- Optimize images with Next.js Image component (if used)

```typescript
// ✅ DO: Memoize expensive components
export const BoardCard = React.memo(function BoardCard({ board }: { board: Board }) {
  // Component implementation
})
```

## Environment Variables

### Required Variables

```bash
# .env.local
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
```

- **Never commit** `.env.local` to git
- Use `NEXT_PUBLIC_` prefix for client-accessible variables
- Validate env vars at build time

```typescript
// ✅ DO: Validate environment variables
if (!process.env.NEXT_PUBLIC_SUPABASE_URL) {
  throw new Error('Missing NEXT_PUBLIC_SUPABASE_URL')
}

if (!process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY) {
  throw new Error('Missing NEXT_PUBLIC_SUPABASE_ANON_KEY')
}
```

## Taskmaster Integration

- **Follow [dev_workflow.mdc](mdc:.cursor/rules/taskmaster/dev_workflow.mdc)** for task management
- Use Taskmaster MCP tools for task operations
- Update subtasks with implementation findings
- Mark tasks as done when complete

## Code Organization

### File Naming

- **Use kebab-case** for file names: `board-card.tsx`, `auth-form.tsx`
- Use PascalCase for component names: `BoardCard`, `AuthForm`
- Keep file names descriptive and aligned with component names

### Export Patterns

- **Named exports** for components and utilities
- Default exports only for pages and layouts
- Group related exports in index files when helpful

```typescript
// ✅ DO: Named exports
export function createBoard(name: string) { }
export function updateBoard(slug: string, data: BoardData) { }
export function deleteBoard(slug: string) { }

// ✅ DO: Default export for pages
export default function DashboardPage() { }
```

## Git Workflow

### Commit Messages

- Use conventional commits: `feat:`, `fix:`, `refactor:`, `docs:`, etc.
- Reference task IDs when applicable: `feat(board): implement auto-save (task #7)`
- Include scope: `feat(auth): add email validation`

### Branch Strategy

- Create feature branches from main
- Use Taskmaster tags for feature isolation if needed
- Keep commits focused and atomic

## References

- [Next.js App Router Docs](https://nextjs.org/docs/app)
- [Supabase Docs](https://supabase.com/docs)
- [Excalidraw Docs](https://docs.excalidraw.com/)
- [PRD](mdc:.taskmaster/docs/prd.txt)
- [Taskmaster Workflow](mdc:.cursor/rules/taskmaster/dev_workflow.mdc)